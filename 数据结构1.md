# 数据结构

# 一，数据结构的逻辑表示

## 1，线性逻辑（表结构）

元素与元素之间存在1：1的关系

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501121153526.png" alt="QQ20250112-115302" style="zoom:50%;" />

## 2，非线性逻辑

### 层级关系（树结构）

每个元素往下

元素和元素之间存在1：n的关系

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501121151296.png" alt="QQ20250112-115127" style="zoom:50%;" />

### 图集关系（图结构）

元素和元素之间存在m：n的关系

# 二，数据结构的存储结构

用不同的存储结构能表示同一个逻辑

## 1，顺序存储

## 2，链式存储

# 三，顺序表结构

将这三个定义在一个结构头里，这样就不需要每次使用时都写一遍这三个东西的真实值，只需要用这个结构头就能操作这三个东西

## 1，一个数组

空间首地址

## 2，位置索引

待插入的位置

## 3，尾部标识

指向当前空间最后位置+1的那个位置。

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501121512441.png" alt="QQ20250112-151154" style="zoom:50%;" />

## 4，XX结构头

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501121525480.png" alt="QQ20250112-152438" style="zoom: 67%;" />

## 5，顺序表类型

### 5.1 固定顺序表

### 5.2动态扩容顺序表

可变数组

# 四，cmake的运用

1，
<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501121546034.png" alt="QQ20250112-154640" style="zoom: 67%;" />

2，那么怎么去实现呢？用一个add_subdirectory()函数

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501121553589.png" alt="QQ20250112-155302" style="zoom: 67%;" />

3，在工作中，我们只需要写函数接口就行，因为组长才是main()函数，我们只需要提供函数给他去检测。那么我们应该怎么写代码呢？

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501121600323.png" alt="QQ20250112-160038" style="zoom: 67%;" />

4，我们在写完.c  .h 文件后，怎么维护呢？用到cmake

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501121747556.png" alt="QQ20250112-174744" style="zoom:67%;" />

# 五，链式表结构

链表的单位：节点 = 数据+指针域

## 1，头形式

### 1.1 带头指针的链表（后学）

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501141132410.png" alt="QQ20250114-113158" style="zoom:67%;" />

记住一句话：

所以带头指针的链表，比如node_t * head 。都要定义一个dummy节点（临时节点），充当头节点



写函数时，先定义dummy节点，node_t dummy 。然后令dummy.next = head。

那么就可以按带头节点的链表的形式来写了。要dummy的首地址记得&。

在代码最后，写  head = dummy.next  还回去就行了



### 2.2 带头结点的链表（先学）

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501141137509.png" alt="QQ20250114-113534" style="zoom:67%;" />



## 2,单向链表特点

### a.  

​	一旦离开当前节点，就再也找不到这个节点。不可逆，没有回头路。

​	链表的插入操作，一定是在待插入节点的前一个节点停止，再进行插入和删除。

### b.

 	一旦p->next指向了别的节点后，此时链表的原来逻辑关系就断开，所以要插入新节点，就要先备份

​	先储存20的首地址（备份），再用新节点指向20的首地址，然后10就能指向100了。这样就完成了插入（这是一种思想，删除会用）

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501141152567.png" alt="QQ20250114-115232" style="zoom: 67%;" />

## 3,链表的插入

先处理新节点，再处理老节点

new_node->next = p->next;

p->next = new_node;

## 4，链表的删除

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501141214299.png" alt="QQ20250114-121434" style="zoom:67%;" />

记住释放删除的节点

tmp = p->next;

p->next = tmp->next;

free(tmp);

# 六，单向循环链表

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501151646763.png" alt="QQ20250115-164557" style="zoom:80%;" />

## 1，约瑟夫环

带头指针的链表

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501161136666.png" alt="QQ20250116-113607" style="zoom:67%;" />

# 七，双向循环链表

## 1，基本插入逻辑

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501171921595.png" alt="QQ20250117-192059" style="zoom: 67%;" />

## 2，基本删除逻辑

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501171925799.png" alt="QQ20250117-192446" style="zoom:67%;" />

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501171925807.png" alt="QQ20250117-192530" style="zoom: 67%;" />

# 八，栈和队列

## 一，栈和队列的区分

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501181543365.png" alt="QQ20250118-154329"  />

# 九，树的概念及存储

## 1，树的概念

![QQ20250121-122937](https://gitee.com/YUCHI---yu/picture/raw/master/img/202501211229870.png)

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501211230642.png" alt="QQ20250121-123027" style="zoom:80%;" />

## 2，树的存储结构

二叉树只适合存储，不适合运算

![QQ20250121-125818](https://gitee.com/YUCHI---yu/picture/raw/master/img/202501211258328.png)

# 十，二叉树

## 满二叉树

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501211546255.png" alt="QQ20250121-154638" style="zoom: 80%;" />

## 完全二叉树

按照满二叉树的形式从上到下，从左到右填。如果因为n不够，填不满，但是形式又和满二叉树一样。就叫做完全二叉树。

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501211557453.png" alt="QQ20250121-155708" style="zoom:50%;" />

## 二叉树的性质

### 性质3

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501211619284.png" alt="QQ20250121-161922" style="zoom:80%;" />

理解：

1,n表示全部节点个数，n0表示节点度为零的节点，n1表示节点度为一的节点，n2表示节点度为二的节点。

​	n = n0 + n1 + n2;

2,然后理解为倒过来的棒棒糖。但是根没有树根

n = 树根数 + 1；

然后节点度为2的节点有两条树根，节点数为1的节点有一条树根，节点数为0的节点有零条树根

树根数 = 2 * n2 + 1 * n1 + 0 * n0;

n = 2 * n2 + n1 + 1;



所以 n2 + 1 = n0;

### 性质5

树结果仍然可以顺序存储，但是前提，根节点为1号，按照满二叉树的形式开始补充空间

然后有这个结论：一个数是 m号 ， 那么它爸是 m/2号（c语言取整）  ,它的左孩子是 2*m 号, 它的右孩子是 2 * m + 1号;

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501211649806.png" alt="QQ20250121-164928" style="zoom: 50%;" />

## 二叉树的实现

树的形式

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501211824693.png" alt="QQ20250121-182332" style="zoom:67%;" />

## 二叉树的遍历

### 1，深度遍历

#### 1，先序遍历（递归）

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501211848894.png" alt="QQ20250121-184832" style="zoom: 67%;" />

#### 2，中序遍历

#### 3，后序遍历

### 2，广度遍历

### 3，深度非递归遍历

# 十一，线索二叉树

## 1，背景介绍

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202501231456994.png" alt="QQ20250123-145619" style="zoom:67%;" />

## 2，中序线索化

# 十二，二叉搜索树（BST）

也称二叉排序树，因为只要结果一次中序遍历，就从小到大排好

# 十三，时间空间复杂度

# 十四，二叉平衡树

# 十五，树和森林与二叉树的转换

# 十六，并查集

重点：合并，查询

# 十七，哈夫曼树

## 一

![QQ20250205-143834](https://gitee.com/YUCHI---yu/picture/raw/master/img/202502051438814.png)

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202502051439997.png" alt="QQ20250205-143944" style="zoom:67%;" />

哈夫曼树就是带权路径之和最小的那颗树

## 二，哈夫曼树中数编码

左0右1

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202502051458200.png" alt="QQ20250205-145802" style="zoom:80%;" />

# 十八，图

## 路径和路径长度

![QQ20250218-183356](https://gitee.com/YUCHI---yu/picture/raw/master/img/202502181834063.png)

## 回路或环

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202502181838368.png" alt="QQ20250218-183801" style="zoom:67%;" />

## 连通和连通图

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202502181840996.png" alt="QQ20250218-184026" style="zoom: 67%;" />

## 强连通和强连通图

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202502181844120.png" alt="QQ20250218-184405" style="zoom:67%;" />

## 权和网

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202502181847905.png" alt="QQ20250218-184656" style="zoom:67%;" />



# 十九，邻接矩阵（无向图）

初始化建议没有关系的边定义为最大值（INF）

因为可能涉及最小路径（带权）要找最小值

<img src="https://gitee.com/YUCHI---yu/picture/raw/master/img/202502181943550.png" alt="QQ20250218-194323" style="zoom:67%;" />

# 二十，邻接表（有向图）

![QQ20250218-212432](https://gitee.com/YUCHI---yu/picture/raw/master/img/202502182124404.png)

# 二十一，图的DFS和BFS

## DFS























